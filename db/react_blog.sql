/*
Navicat MySQL Data Transfer

Source Server         : mysql
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : react_blog

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2020-02-26 09:35:34
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `admin_user`
-- ----------------------------
DROP TABLE IF EXISTS `admin_user`;
CREATE TABLE `admin_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of admin_user
-- ----------------------------
INSERT INTO `admin_user` VALUES ('1', 'jacky', '123456');

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章编号',
  `type_id` int(11) DEFAULT NULL COMMENT '文章类型编号',
  `title` varchar(255) DEFAULT NULL COMMENT '文章标题',
  `article_content` text COMMENT '文章主体内容',
  `introduce` text COMMENT '文章简介',
  `add_time` int(20) DEFAULT NULL COMMENT '文章发布时间',
  `view_count` int(11) DEFAULT '0' COMMENT '浏览次数',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', '1', 'sessionStorage、localStorage用法总结', '在工作中使用sessionStorage存储数据时，发现sessionStorage无法直接存储数组和对象，如存入对象则显示为\"[object Object]\"，对此作下记录，重新温习sessionStorage和localStorage\n\nhtml5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage\n\n## 共同点\n\n存储大小为5MB，都保存在客户端，不与服务器进行交互通信，有相同的Web API\n\n## sessionStorage、localStorage区别\n\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n\nsessionStorage 数据在当前浏览器窗口关闭后自动删除。\n\n因此**sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期**，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期\n\n## Web Storage API\n\nlocalStorage 和 sessionStorage 有着统一的API接口，下面以sessionStorage为例介绍一下 API 接口使用方法\n\n### 添加键值对\n**setItem(key,value)：为指定key值设置一个对应的value值**\n\n除了使用setItem方法，还可以使用sessionStorage.key = value或者sessionStorage[\'key\'] = value这两种形式。\n\n```javascript\n// 把name值存储到name的键上\nsessionStorage.setItem(\'name\', \'jacky\'); // 法1 \n// sessionStorage.name = \'jacky\'; // 法2 \n// sessionStorage[\'name\'] = \'jacky\'; // 法3 \n```\n**添加数组和对象**\n\n需要注意的是key和value值必须是**字符串形式**的，如果不是字符串，会调用它们相应的toString()方法来转换成字符串再存储。\n\n所以要存储数组或对象时，应先转换成字符串格式（如JSON格式）再进行存储，使用**JSON.stringify(obj)方法**\n\n```javascript\nvar obj = {\n    name: \'jacky\', \n    age: 22\n};\nsessionStorage[\'person\'] = JSON.stringify(obj);\n//sessionStorage[\'person\'] = obj; 不能这样存储，这样存进去结果是\"[object Object]\"\n```\n\n存进去之后则为字符串格式\n```javascript\n \"{\"name\":\"jacky\",\"age\":22}\"\n```\n\n需要拿出来使用的时候则使用**JSON.parse()方法**将JSON字符串转换为对象\n```javascript\nvar person = JSON.parse(sessionStorage[\'person\'])\n```\n同理，数组也是这个用这个方法进行存储。\n\n### getItem（key）：根据指定的key值获取对应的value值\n\n和setItem一样，getItem也有两种等效形式,value = sessionStorage.key和value = sessionStorage[\'key\']。获取到的 value 值是字符串类型，如果需要其他类型，需要自己做类型转换。\n```javascript\n// 获取存储到 name 的键上的值\nvar name = sessionStorage.getItem(\'name\');\n// var name = sessionStorage.name;\n// var name = sessionStorage[\'name\'];\n```    \n\n### removeItem（key）：删除指定的key值对应的value值\n注意localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。\n```javascript\n    var name = sessionStorage.getItem(\'name\'); // \"jacky\"\n    sessionStorage.removeItem(\'name\');\n    name = sessionStorage.getItem(\'name\'); // null\n```\n\n### clear()：删除所有存储的内容\n它和removeItem不同的地方是removeItem删除的是某一项，而clear是删除所有。\n```javascript\n    // 清除 localStorage\n    sessionStorage.clear();\n    var len = sessionStorage.length; // 0\n    //length属性用于获取 sessionStorage 中键值对的数量。\n```\n\n### key(index)：在指定的数字位置获取该位置的名字\n需要注意的是赋值早的键值对应的索引值大，赋值完的键值对应的索引小,key方法可用于遍历 sessionStorage 存储的键值。\n```javascript\n    sessionStorage.setItem(\'name\',\'jacky\');\n    var key = sessionStorage.key(0); // \'name\'\n    sessionStorage.setItem(\'age\', 10);\n    key = sessionStorage.key(0); // \'age\'\n    key = sessionStorage.key(1); // \'name\'\n```\n\n## 两者应用场景\n### sessionStorage应用场景\n进行页面传值\n\n### localStorage应用场景\n1. 适合长期保存在本地的数据\n2. 可以用于存储该浏览器对该页面的访问次数', '在工作中使用sessionStorage存储数据时，发现sessionStorage无法直接存储数组和对象，如存入对象则显示为\"[object Object]\"，对此作下记录，重新温习sessionStorage和localStorage\n\nhtml5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage\n\n存储大小为5MB，都保存在客户端，不与服务器进行交互通信，有相同的Web API\n\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n\nsessionStorage 数据在当前浏览器窗口关闭后自动删除。', '1582128000', '1458');
INSERT INTO `article` VALUES ('3', '1', '深入理解JavaScript之执行上下文和执行栈', '都说想成为出色的JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍JS的执行上下文和执行栈，以此作总结。\n\n首先先来了解几个专业概念\n\n- EC：函数执行环境（或执行上下文），Execution Context\n\n- ECS：执行环境栈，Execution Context Stack\n\n- VO：变量对象，Variable Object\n\n- AO：活动对象，Active Object\n\n- scope chain：作用域链\n\n## 什么是执行上下文\n\n每次当控制器转到ECMAScript可执行代码的时候，它都是在执行上下文中运行，即是指当前执行环境中的变量、函数声明，参数，作用域链，this等信息。\n\n### 组成代码示例\n```javascript\nconst ExecutionContextObj = {\n    VO: window,     // 变量对象\n    ScopeChain: {}, // 作用域链\n    this: window\n};\n```\n\n## 执行上下文的类型\n\n\nJavaScript 中有三种执行上下文类型。\n\n1. **全局执行上下文**——  这是默认上下文，浏览器中的全局对象就是window对象，任何不在函数内部的代码都在全局上下文中，this指向这个全局对象。\n\n2. **函数执行上下文** —— 当**函数被调用时创建**,会为该函数创建一个新的执行上下文，可以有任意个。 \n\n3. **Eval 函数执行上下文** —— \n执行 eval函数内部的代码也有属于它的上下文，由于开发中是尽量避免或不用eval函数，故此不作讨论。\n\n## 执行栈\n\n执行栈，也叫调用栈，被用来存储代码运行时创建的所有执行上下文。\n>栈：一种数据结构，遵循后进先出的原则\n \n当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。\n \n引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。\n\n```javascript\nfunction fn1() {\n  console.log(\'fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈\');\n  fn2(); \n  console.log(\'fn2执行完成，fn2的执行上下文会从栈中弹出\');\n}\n\nfunction fn2() {\n  console.log(\'fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈\');\n}\n\nfn1();\nconsole.log(\'fn1执行完成，fn2的执行上下文会从栈中弹出\');\n```\n运行结果：\n```\nfn1被调用了 -- 创建了fn1的函数执行上下文，压入栈\nfn2被调用了 -- 创建了fn2的函数执行上下文，压入栈\nfn2执行完成，fn2的执行上下文会从栈中弹出\nfn1执行完成，fn2的执行上下文会从栈中弹出\n```\n上述代码的执行上下文栈：\n![](https://user-gold-cdn.xitu.io/2019/11/27/16ead7c041a4b415?w=1276&h=316&f=png&s=30716)\n\n当上述代码在浏览器加载时，JavaScript引擎创建了一个全局执行上下文并把它压入栈中，当函数fn1()被调用时，JavaScript为该函数创建了一个函数执行上下文，并把它压入当前执行栈的顶部。\n \n当fn1()函数内部调用fn2()函数时，JavaScript引擎同样创建了fn2()的函数执行上下文并压入栈的顶部。然后执行了fn2()函数后，fn2()函数会从当前栈（后进先出结构）弹出，并且按程序执行顺序继续执行fn1()函数，即此刻处于fn1的函数执行上下文。\n \n当 fn1()函数执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。\n\n## 执行上下文的创建\n\n已经知道JavaScript 怎样管理执行上下文了，现在来了解JavaScript引擎是怎么创建执行上下文的。\n\n创建执行上下文有两个阶段：\n\n1. 创建阶段\n2. 执行阶段。\n\n在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：\n1. this绑定\n2. 创建(LexicalEnvironment)词法环境组件\n3. 创建(VariableEnvironment)变量环境组件\n\n执行上下文在概念可表示为：\n```\nExecutionContext = {\n  ThisBinding = <this value>,\n  LexicalEnvironment = { ... },\n  VariableEnvironment = { ... },\n}\n```\n## 1. 创建阶段\n### this 绑定\n\n在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用window对象)\n\n在函数执行上下文中，this的指向取决于函数是如何被调用的,在本篇暂不对this指向做详细讨论。\n\n```javascript\nlet obj = {\n    fn: function() {\n        console.log(this);\n    }\n}\nlet win = obj.fn;\n\nobj.fn(); //this指向obj\nwin(); // this指向window\n```\n\n### 词法环境（Lexical Environment）\n\nES6官方文档把词法环境定义为：\n\n> 词法环境是用来定义 基于词法嵌套结构的ECMAScript代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为null的对外部词法环境的引用（outer）组成。一般来说，词法环境都与特定的ECMAScript代码语法结构相关联，例如函数、代码块、TryCatch中的Catch从句，并且每次执行这类代码时都会创建新的词法环境。\n\n可以理解为词法环境是一种包含标识符(变量/函数的名称)和变量(函数/原始值/数组对象等)映射的数据结构\n\n#### 词法环境有两个组成部分\n\n1. 声明式环境记录器：存储变量和函数声明的实际位置\n\n2. 对象环境记录器：可以访问其外部词法环境(作用域)\n\n#### 词法环境有两种类型\n\n1. 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。\n\n2. 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。\n\n### 变量环境 (VariableEnvironment)\n\n变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。\n\n在ES6中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量let和const绑定，而后者仅用于存储变量var绑定。\n\n## 2.执行阶段\n\n在此阶段，完成对所有这些变量的分配，最后执行代码。（在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined）\n\n\n\n\n', '都说想成为出色的JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍JS的执行上下文和执行栈，以此作总结。\n\n首先先来了解几个专业概念\n\n- EC：函数执行环境（或执行上下文），Execution Context\n\n- ECS：执行环境栈，Execution Context Stack\n\n- VO：变量对象，Variable Object\n\n- AO：活动对象，Active Object\n\n- scope chain：作用域链', '1582189786', '845');
INSERT INTO `article` VALUES ('2', '2', '为什么要学习投资理财', '说到投资理财，很多人想到的是炒股，于是投资理财被人归为尽量避而不谈的话题；也有人想到的是省钱，投资理财就是拼命省钱。各种各样的说法。\r\n\r\n然而谁都很难一次性解释清投资理财的概念，因为它包含的领域方方面面，到我们生活的每一处，它是一门学问，但是学习门槛很低，它是我们每个人应该具备的一项技能，因为它跟我们生活密切相关。\r\n\r\n## 1.看清和避开投资理财陷阱与骗局\r\n\r\n近几年，可以说大众理财不断兴起，各种各样的投资产品被我们所听闻，也伴随着大量被骗钱的事件发生。不论是银行理财产品还是保险，都存在着被忽悠的可能。如果没有一双慧眼，就可以掉入其中的陷阱。学习投资理财，正是看清和避开这些陷阱。\r\n\r\n## 2.保持资产增值\r\n\r\n据相关数据统计，我国每年的通货膨胀率为5%，当然这个数据不一定准确但也在这个范围内。这意味着我们存进银行的钱，若干年都是在不断的贬值，钱的购买力降低，实际上也是一种变相的亏损。\r\n\r\n学习投资，通过合理的资产配置，可以让我们的钱不贬值反而增值，而保持一定高的年化收益率，更是让我们财富处在上升的通道，最终财务自由。\r\n\r\n## 3.抵御意外事故\r\n\r\n正确的理财规划和资产配置能帮助我们在风险到来的时候发挥作用，比如人身突然出了意外需要大笔医疗开支，如果有配置相关的保险，在关键时刻就能免受经济压力的负担。\r\n\r\n## 4.保障养老生活\r\n\r\n退休后如何保持经济独立，能够维持正常的老年生活，是现代人都要面对的一个问题。工作赚下的钱，能否保证退休后够用呢？看过一句话：活得久也是风险。这句话暗示的是你的资产没有保障到你的岁数，虽然活得久，但是钱不够用了，也是很悲惨的。\r\n\r\n可能有人会说，我有社保，有养老险，但想度过一个美好的晚年仅仅靠它是不够的，更多现实案例是更惨甚至都度不过，所以必须自己制定好养老理财计划，这又是需要具备点投资理财知识，保障财富的稳健与增值。\r\n\r\n## 5.理财就是理生活\r\n\r\n如果要将投资理财归结为一句话，那么这句话最好的回答：理财就是理生活。学习理财的过程实际也是在规划我们自己的生活，在人生的不同阶段，让我们财务状况运行良好从而满足不同的人生规划需求。\r\n\r\n我相信，会理财的人，有掌控生活的能力，也会追求更美好的生活。这个度就是每个人对投资理财不同的要求，有人可能偏于稳健，有人可能偏于使财产维持高收益。\r\n\r\n但是，不管怎么样，如果投资理财让你越来越不舒服，那说明是你的方式错了。每个人都有自己的投资理财方式，找到适合自己的就是最好的。\r\n\r\n​', '说到投资理财，很多人想到的是炒股，于是投资理财被人归为尽量避而不谈的话题；也有人想到的是省钱，投资理财就是拼命省钱。各种各样的说法。然而谁都很难一次性解释清投资理财的概念，因为它包含的领域方方面面，到我们生活的每一处，它是一门学问，但是学习门槛很低，它是我们每个人应该具备的一项技能，因为它跟我们生活密切相关。', '1582189924', '687');
INSERT INTO `article` VALUES ('4', '3', '读《把时间当作朋友》后感', '最近读完了一本书《把时间当作朋友》，其实主要感受是这本书有点属于励志类的书，其中心思想是主张时间不可管理，时间也不听从任何人的管理，它只会一如既往地流逝。所以要管理的不是时间，而是我们自己。\r\n\r\n## 1.心智的力量\r\n这里说的\"心智\"，说的并不是智力，它主要是包括以下三方面能力：a.获得知识  b.应用知识  c.抽象推理  |  一个人的心智就是其过往获得的一切知识及经验的总和，包括基于这些知识和经验造就的思考方法，思考模式。每个人拥有的心智力量都有差异，这些差异会给每个人的一生带来不同的结果。\r\n\r\n运用心智的力量，首先要学会控制我们自己的大脑。一个人拥有活跃的大脑是好事，但是，很多时候也可能是坏事，比如在忙碌学习的时候，不时会看一下手机、浏览新闻、刷一下朋友圈，我们的大脑表现得非常活跃，并且你的注意力最容易接受它的指令。\r\n\r\n所以，甚至我们自己都没有意识到的情况下，它在不停地操控你的注意力。然后，你就这样轻易被你的大脑所左右了。\r\n\r\n所以，尽管我们用大脑思考，仿佛它在指导我们的行为。但是，你要明白你不应该隶属你的大脑，而是要拥有你的大脑，去有意识的控制大脑。\r\n\r\n## 2.如何与时间做朋友\r\n精确感知时间，记录自己的时间开销。使用列表能减少失误：\r\n\r\n（一） 不必所有的情况都制作列表\r\n\r\n（二） 最好的列表记录工具是纸和笔\r\n\r\n（三） 列表不必要工整\r\n\r\n（四） 列表一定要随手可及\r\n\r\n（五）最重要的任务永远只有一个\r\n\r\n（六） 制作专门的下一个阶段任务列表\r\n\r\n## 3.小心所谓\"成功学\"\r\n成功究竟是什么，好像谁都知道，却又谁都说不清楚，也很难找到一个统一的定义。字典的解释倒是简单明了，所谓成功，就是达成预期目标。\r\n\r\n每个人都渴望成功。基于某种原因，所以被认为成功的人也都乐于分享他们成功的经验。可是，很多成功者，在讲述自己的成功经历时，都会有意无意地夸大自己成功所付出的代价，夸大曾经面临、战胜的困境。这不是他们故意的，因为他们也是人，跟所有普通人一样都有不同程度的虚荣心需要获得满足。\r\n\r\n他们这么做，还有另外一个潜意识的根源，为了保护自己。他们如此夸大成功的代价，潜意识里的说法是：\"看吧，成功可不是说来就来的，是需要付出很大代价的，你还是好好想想吧\"——这是另外一种形式的\"恐吓\"。\r\n\r\n在本书中，作者告诉我们存在这样一个事实：有些时候，\"成功者\"的经验根本没有用，因为那些经验根本就是错误的，关键在于他们自己可能也并不知道。\r\n\r\n比如，他们遇到了经济飞速增长的时代，无论做什么都赚钱而且赚得很多，所以从宏观上看，是宏观经济给了他们这样的机会。所以，要知道有些\"宝贵经验\"就算正确，放到你自己就可能并不那么灵验。\r\n\r\n有一个很实用的建议是：不妨反其道而行之——努力从失败者身上汲取经验。成功者很多，但是，你身边的成功者却很少；其背后的东西你也难以看清楚，其真实性也难以判断，而他们又会有意无意地美化包装他们的经验，而这一切，都在干扰我们的判断。只有经过仔细甄别之后，真正的成功者的宝贵经验，才是无价的。\r\n\r\n但观察失败者却要相对容易得多，因为他们的失败往往是显然而确定的，而失败的原因往往很容易确定，尽管失败者会找各种各样的接口，但是你有更多的观察机会。\r\n\r\n所以，有了这样的认识，你就经常遇到所谓的幸运——当你快要犯错误的时候，有人在你之前犯了同样的错误。当然，\"专注于汲取教训，而不是花时间去幸灾乐祸\"。\r\n\r\n4.打造人脉不如先打造自己\r\n某种意义上，尽管大多数人不愿意承认，但他们所谓的\"友谊\"，实际上不过是\"交换关系\"。为了打造人脉，我们也可能硬着头皮去帮助一个自认为是\"人脉\"的人。\r\n\r\n我认为，人脉是需要的，但不可太刻意委屈自己去强求，比如做自己很难办到的事情。\r\n\r\n作者在书中告诉我们：\r\n\r\n承认自己能力有限；\r\n\r\n不怕在别人面前露怯；\r\n\r\n敢于不去证明自己是\"好人\"\r\n\r\n往往只有优秀的人才拥有有效的人脉\r\n\r\n这本书观点很多，在本文只叙述和总结了小部分观点，这是一本\"不是很实际用途\"的书，但看了又会引发人较多的思考。\r\n\r\n读一本书，最大的受益就是冲击人的思想风暴，让人去思考很多平时没有注意的事情。我喜欢揣摩个人内心的动向，所以也更喜欢心理学。\r\n\r\n保持阅读的习惯，我相信，除了努力和运气成分，改变人生命运的无非两样东西：一个是你读过的书，一个是你遇到的人。', '最近读完了一本书《把时间当作朋友》，其实主要感受是这本书有点属于励志类的书，其中心思想是主张时间不可管理，时间也不听从任何人的管理，它只会一如既往地流逝。所以要管理的不是时间，而是我们自己。\r\n', '1582128000', '1356');
INSERT INTO `article` VALUES ('9', '2', '货币基金的来龙去脉', '之前我们讲到了基金的类型，这一次我们继续进入基金的篇章，这一次谈的是货币基金。\n\n为什么投资一开始不要说买买买，因为你连你买的基金投资什么都不知道，甚至买的东西本身也不知道是什么，投资风险就很难评估了。\n\n没有经历过亏损，你就会明白股市的钱不是想捞就能捞，给你买就能赚到的。短时间能赚到的钱，长期来看，大概率你会亏回去。\n\n敬畏股市，尊重投资本身，先做好最基本的，你才能顺利踏入投资理财这一大门。\n\n今天，我们终于进入具体的一类基金了，对基金的认识大家已经清楚了，货币基金，想认识它，首先得知道它是怎么产生的。\n\n\n## 1.货币基金是怎么产生的\n\n首先要说到银行，其实银行也跟我们普通人一样，也会有出现资金短缺或者盈余的时候，所以各大银行经常会互相借钱，这个就叫银行间的互相拆借，这样就形成了银行间市场。\n\n借钱这在金融市场大家很熟悉，类似花呗、信用卡都是我们在跟他们借钱花，但银行的借贷市场不一样的是，银行的拆借资金量大而且时间短，比如隔夜、三天、七天的居多。\n\n所以银行之间的货币市场是一个短期的过程，而且资金量庞大，既然如此，它对钱的流动性要求就很高了，而且追求短时间的利用率，利率自然也会远远高于银行给储户的利率。\n\n可是，银行利率虽然高，但是它们都不允许个人投资者进入。\n\n在上个世纪70年代的时候，美国规定活期存款没有利率，定期存款的利率有上限但也不高。大家手上的钱都想要增值，但没门槛也不是专业人士。\n\n于是，大量的储蓄都有一种寻找更高收益的冲动，这个时候美国有一个投资银行家就想出了一个办法，他设立了一个基金，集合老百姓手里的钱，积少成多，然后把钱投向利率比较高的银行间货币市场。\n\n这其实就是用大家每个人手里的少量资金凑成大额资金，参与了高收益的银行间市场，从而间接分享到了机构投资者才有的vip收益。\n\n看到这里，大家是不是对基金的概念更清晰了，如果你看过我这篇文章：基金是什么？\n\n由于这些基金的投向主要是银行间的货币市场，所以又叫\"货币基金\"。货币基金不属于银行体系，不用缴纳存款准备金，也不受利率的管制，因此投资收益能比银行存款高得多。\n\n## 2.货币基金特点\n\n在现在，货币基金的投资的范围也不只有银行之间的拆借，它主要投资于风险较低的货币市场。\n\n比如有国债、中央银行票据、企业债券、短期有价证券、银行定期存单、政府短期债券等。\n\n投资它们整体给我们的感觉就是稳，安全，所以货币基金的安全性高。在投资的分类里面，货币基金属于低风险，低收益，高流动性。\n\n低收益大家就能理解了，目前就2.5%前后的水平大部分的货币基金，但是呢，相比银行活期存款，还是要高得多的。\n\n目前的货币基金，在流动性方面，还是有些差别的。有的赎回需要一天，有的可以两小时到账，有的甚至可以即时到账，总体上看，货币基金具备高流动性的特点。\n\n## 3.余额宝也是货币基金\n\n余额宝其实就是一只货币基金，当时只是一只天弘余额宝货币基金，把钱转入余额宝就相当于买入了同等份额的天弘余额宝货币基金。依靠支付宝这个背景，余额宝也具备了消费功能，这是其他货币基金不能做到的。\n\n现在余额宝不止一只基金了，可以切换基金，余额宝有很多只货币基金供我们选择。\n\n我们可以打开支付宝，一探究竟，打开支付宝的余额宝界面，点击右上方的三个点，选择基金详情\n\n比如我目前持有的货币基金叫做兴全天利宝，近1个月的7日年化收益率为2.7%。而如果你从来没更换过基金，那显示的应该为天弘余额宝基金，而它近1个月的7日年化收益率为2.4%，略低于我选的这只。\n\n这是我很久之前更换的，因为当时看长期收益率高于原来的天弘余额宝货币基金，虽然现在也不是所有货币基金里收益最高的那只了，不过我比较懒得折腾，很长一段时间才会更换一次货币基金。\n\n如果你只盯着收益看，每1个月甚至每7天都各基金收益率高低排名都不一样。必须强调的是，短期收益率高不代表未来收益率高，只是大概率未来会继续高而非绝对。\n\n大家如果重新挑选货币基金，建议参考近6月，近1年的收益率，页面下方可以进行选择，7日年化只是反应这一周的收益率水平，要选就选长时间保持稳定的收益率水平。\n\n而且，不要折腾，频繁的更换基金，也是会损失收益的。\n\n说完这些，至于怎么更换基金，在此页面按查看更多产品就能看到了\n\n今天关于货币基金就讲到这里，下次继续~~~\n', '货币基金的投资的范围也不只有银行之间的拆借，它主要投资于风险较低的货币市场。', '1582646400', '1008');

-- ----------------------------
-- Table structure for `type`
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '类型编号',
  `type_name` varchar(255) DEFAULT NULL COMMENT '文章类型名称',
  `order_num` int(11) DEFAULT NULL COMMENT '类型排序编号',
  `icon` varchar(255) DEFAULT '' COMMENT '图标',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES ('1', '技术博文', '1', 'read');
INSERT INTO `type` VALUES ('2', '理财推文', '2', 'folder');
INSERT INTO `type` VALUES ('3', '生活', '3', 'smile');
